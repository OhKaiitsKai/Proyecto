<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pantry Pursuit: Supermarket</title>
</head>
<body>
    <script type="module">
        import * as THREE from "./three.module.js";
        import { OrbitControls } from "./OrbitControls.js";
        import { MTLLoader } from "./MTLLoader.js";
        import { OBJLoader } from "./OBJLoader.js";

        const scene = new THREE.Scene();

        // Load background texture
        const textureLoader = new THREE.TextureLoader();
        const backgroundTexture = textureLoader.load('supermarket.jpg', (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            texture.encoding = THREE.sRGBEncoding;
            scene.background = texture;
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === "Escape") {
                window.location.href = "Pausa.html";
            }
        });

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 5);

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.listenToKeyEvents(window);
        controls.keys = { LEFT: 'KeyA', UP: 'KeyW', RIGHT: 'KeyD', BOTTOM: 'KeyS' };
        controls.enableZoom = false;
        controls.enableRotate = false;

        const addSupermarketElements = (scene) => {
            const floorGeometry = new THREE.PlaneGeometry(100, 100);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0xCED6C4, transparent: true, opacity: 0.8 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            const ambientLight = new THREE.AmbientLight(0x404040, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1.5);
            directionalLight.position.set(1, 3, 2);
            scene.add(directionalLight);
        };

        addSupermarketElements(scene);

        //JUGADOR

        let cart;
        let cartBox;
        let contF1Box, contF2Box, contF3Box, contF4Box;
        let contC1Box, contC2Box, contC3Box, contC4Box;
        let est1Box, est2Box, est3Box, est4Box, est5Box, est6Box, est7Box, est8Box, est9Box, est10Box, est11Box, est12Box, est13Box, est14Box, est15Box, est16Box;

        const createBoundingBox = (object) => {
            const box = new THREE.Box3().setFromObject(object);
            return box;
        };

        const updateBoundingBox = (box, object) => {
            box.setFromObject(object);
        };

        const loadCartModel = (scene, setCartVariable, setBoxVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Carrito/');
            mtlLoader.load('carrito.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Carrito/');
                objLoader.load('carrito.obj', (object) => {
                    const texture = textureLoader.load('Texturas/carritoP1.png');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(0, .35, 0);
                    scene.add(object);
                    setCartVariable(object);
                    setBoxVariable(createBoundingBox(object));
                });
            });
        };

        loadCartModel(scene, (c) => { cart = c; cartBox = createBoundingBox(c); });

        // Enemigo (Caja Negra)
        let enemy, enemyBox;
        const enemyGeometry = new THREE.BoxGeometry(1, 1, 1);
        const enemyMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
        enemy.position.set(5, 0.5, 5);
        scene.add(enemy);
        enemyBox = createBoundingBox(enemy);

        // Movimiento del enemigo
        const enemySpeed = 0.05;

        //ITEMS

        let Manzana = false;
        let Banana = false;
        let Lata = false;
        let Tomate = false;
        let Durazno = false;
        let Berengena = false;
        let Zanahoria = false;
        let Dona = false;
        let Hamburguesa = false;
        let Bebida1 = false;
        let Papitas = false;
        let Bebida2 = false;
        let Bebida3 = false;
        let Bebida4 = false;

        //Manzana

        let man;
        const LoadManzanamodel = (scene, setmanVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Manzana/');
            mtlLoader.load('uploads_files_3685626_FS-0011+Apples.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Manzana/');
                objLoader.load('uploads_files_3685626_FS-0011+Apples.obj', (object) => {
                    const texture = textureLoader.load('Modelos/Manzana/textures/Apple1_u1_v1_diffuse.jpg');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(2.3, 1.7, -15);
                    object.scale.set(5, 5, 5);
                    scene.add(object);
                    setmanVariable(object);
                });
            });
        };

        LoadManzanamodel(scene, (man) => { man = man; });

        //Banana

        let Ban;
        const LoadBananamodel = (scene, setmanVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Productos/');
            mtlLoader.load('banana_001.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Productos/');
                objLoader.load('banana_001.obj', (object) => {
                    const texture = textureLoader.load('Modelos/Productos/Textures.png');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(3.5, 1.7, -15);
                    object.scale.set(4, 4, 4);
                    object.rotation.y = 90;
                    scene.add(object);
                    setmanVariable(object);
                });
            });
        };

        LoadBananamodel(scene, (Ban) => { Ban = Ban; });

        //Zanahoria

        let Zan;
        const LoadZanahoriamodel = (scene, setmanVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Productos/');
            mtlLoader.load('carrot_001.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Productos/');
                objLoader.load('carrot_001.obj', (object) => {
                    const texture = textureLoader.load('Modelos/Productos/Textures.png');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(1.3, 1.7, -15);
                    object.scale.set(5, 5, 5);
                    object.rotation.y = 30;
                    scene.add(object);
                    setmanVariable(object);
                });
            });
        };

        LoadZanahoriamodel(scene, (Zan) => { Zan = Zan; });

        //Berengena

        let Ben;
        const LoadBerengenamodel = (scene, setmanVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Productos/');
            mtlLoader.load('eggplant_001.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Productos/');
                objLoader.load('eggplant_001.obj', (object) => {
                    const texture = textureLoader.load('Modelos/Productos/Textures.png');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(-1.2, 1.7, -15);
                    object.scale.set(4, 4, 4);
                    object.rotation.y = 10;
                    scene.add(object);
                    setmanVariable(object);
                });
            });
        };

        LoadBerengenamodel(scene, (Ben) => { Ben = Ben; });

        //Durazno

        let Dur;
        const LoadDuraznomodel = (scene, setmanVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Productos/');
            mtlLoader.load('peach_001.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Productos/');
                objLoader.load('peach_001.obj', (object) => {
                    const texture = textureLoader.load('Modelos/Productos/Textures.png');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(-2.3, 1.7, -15);
                    object.scale.set(4, 4, 4);
                    scene.add(object);
                    setmanVariable(object);
                });
            });
        };

        LoadDuraznomodel(scene, (Dur) => { Dur = Dur; });

        //Tomate

        let Tom;
        const LoadTomatemodel = (scene, setmanVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Productos/');
            mtlLoader.load('tomato_001.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Productos/');
                objLoader.load('tomato_001.obj', (object) => {
                    const texture = textureLoader.load('Modelos/Productos/Textures.png');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(-3.5, 1.7, -15);
                    object.scale.set(4, 4, 4);
                    scene.add(object);
                    setmanVariable(object);
                });
            });
        };

        LoadTomatemodel(scene, (Tom) => { Tom = Tom; });

        //Papita

        let Pap;
        const LoadPapitasmodel = (scene, setmanVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Productos/');
            mtlLoader.load('chips_001.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Productos/');
                objLoader.load('chips_001.obj', (object) => {
                    const texture = textureLoader.load('Modelos/Productos/Textures.png');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(-7, 2.2, 4.5);
                    object.scale.set(4, 4, 4);
                    scene.add(object);
                    setmanVariable(object);
                });
            });
        };

        LoadPapitasmodel(scene, (Pap) => { Pap = Pap; });

        //Hamburguesa

        let Bur;
        const LoadBurgermodel = (scene, setmanVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Productos/');
            mtlLoader.load('burger_001.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Productos/');
                objLoader.load('burger_001.obj', (object) => {
                    const texture = textureLoader.load('Modelos/Productos/Textures.png');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(-5.5, 2.4, 5);
                    object.scale.set(4, 4, 4);
                    scene.add(object);
                    setmanVariable(object);
                });
            });
        };

        LoadBurgermodel(scene, (Bur) => { Bur = Bur; });

        //Dona

        let Don;
        const LoadDonamodel = (scene, setmanVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Productos/');
            mtlLoader.load('donut_001.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Productos/');
                objLoader.load('donut_001.obj', (object) => {
                    const texture = textureLoader.load('Modelos/Productos/Textures.png');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(7, 2.4, 4.5);
                    object.scale.set(4, 4, 4);
                    scene.add(object);
                    setmanVariable(object);
                });
            });
        };

        LoadDonamodel(scene, (Don) => { Don = Don; });

        //Bebida 1

        let Beb;
        const LoadBebidamodel = (scene, setmanVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Productos/');
            mtlLoader.load('drink_001.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Productos/');
                objLoader.load('drink_001.obj', (object) => {
                    const texture = textureLoader.load('Modelos/Productos/Textures.png');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(5.5, 2.3, 5);
                    object.scale.set(3, 3, 3);
                    scene.add(object);
                    setmanVariable(object);
                });
            });
        };

        LoadBebidamodel(scene, (Beb) => { Beb = Beb; });
        
        //Bebida 2

        let Beb2;
        const LoadBebidamodel2 = (scene, setmanVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Productos/');
            mtlLoader.load('drink_002.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Productos/');
                objLoader.load('drink_002.obj', (object) => {
                    const texture = textureLoader.load('Modelos/Productos/Textures.png');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(-5.5, 2.3, -3);
                    object.scale.set(3, 3, 3);
                    scene.add(object);
                    setmanVariable(object);
                });
            });
        };

        LoadBebidamodel2(scene, (Beb2) => { Beb2 = Beb2; });
        
        //Bebida 3

        let Beb3;
        const LoadBebidamodel3 = (scene, setmanVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Productos/');
            mtlLoader.load('drink_003.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Productos/');
                objLoader.load('drink_003.obj', (object) => {
                    const texture = textureLoader.load('Modelos/Productos/Textures.png');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(7, 2.3, -2.5);
                    object.scale.set(3, 3, 3);
                    scene.add(object);
                    setmanVariable(object);
                });
            });
        };

        LoadBebidamodel3(scene, (Beb3) => { Beb3 = Beb3; });

        //Bebida 4

        let Beb4;
        const LoadBebidamodel4 = (scene, setmanVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Productos/');
            mtlLoader.load('drink_004.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Productos/');
                objLoader.load('drink_004.obj', (object) => {
                    const texture = textureLoader.load('Modelos/Productos/Textures.png');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(-7, 2.3, -2.5);
                    object.scale.set(3, 3, 3);
                    scene.add(object);
                    setmanVariable(object);
                });
            });
        };

        LoadBebidamodel4(scene, (Beb4) => { Beb4 = Beb4; });

        //ESCENARIOS
        //
        //Contenedores Frutas

        let ContF1, ContF2;
        const LoadContFmodel1 = (scene, setjugVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Frutas/');
            mtlLoader.load('Frutas_Container.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Frutas/');
                objLoader.load('Frutas_Container.obj', (object) => {
                    const texture = textureLoader.load('Texturas/madera.jpg');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(2.3, .8, -15);
                    scene.add(object);
                    setjugVariable(object);
                });
            });
        };

        LoadContFmodel1(scene, (ContF) => { ContF1 = ContF; contF1Box = createBoundingBox(ContF); });
        LoadContFmodel1(scene, (ContF) => { ContF2 = ContF; contF2Box = createBoundingBox(ContF); });

        let ContF3, ContF4;
        const LoadContFmodel2 = (scene, setjugVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Frutas/');
            mtlLoader.load('Frutas_Container.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Frutas/');
                objLoader.load('Frutas_Container.obj', (object) => {
                    const texture = textureLoader.load('Texturas/madera.jpg');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(-2.3, 0.8, -15);
                    scene.add(object);
                    setjugVariable(object);
                });
            });
        };

        LoadContFmodel2(scene, (ContF) => { ContF3 = ContF; contF3Box = createBoundingBox(ContF); });
        LoadContFmodel2(scene, (ContF) => { ContF4 = ContF; contF4Box = createBoundingBox(ContF); });

        //Estanterias

        let Est1, Est2;
        const LoadEstmodel = (scene, setVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Estanteria/');
            mtlLoader.load('Estanteria.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Estanteria/');
                objLoader.load('Estanteria.obj', (object) => {
                    const texture = textureLoader.load('Texturas/metal.jpg');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(-6, 0, -3);
                    object.rotation.y = -80.1;
                    object.scale.set(2.5, 2.5, 2.5);
                    scene.add(object);
                    setVariable(object);
                });
            });
        };

        LoadEstmodel(scene, (Est) => { Est1 = Est; est1Box = createBoundingBox(Est); });
        LoadEstmodel(scene, (Est) => { Est2 = Est; est2Box = createBoundingBox(Est); });

        let Est3, Est4;
        const LoadEstmodel2 = (scene, setVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Estanteria/');
            mtlLoader.load('Estanteria.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Estanteria/');
                objLoader.load('Estanteria.obj', (object) => {
                    const texture = textureLoader.load('Texturas/metal.jpg');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(-6, 0, 5);
                    object.rotation.y = -80.1;
                    object.scale.set(2.5, 2.5, 2.5);
                    scene.add(object);
                    setVariable(object);
                });
            });
        };

        LoadEstmodel2(scene, (Est) => { Est3 = Est; est3Box = createBoundingBox(Est); });
        LoadEstmodel2(scene, (Est) => { Est4 = Est; est4Box = createBoundingBox(Est); });

        let Est5, Est6;
        const LoadEstmodel3 = (scene, setVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Estanteria/');
            mtlLoader.load('Estanteria.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Estanteria/');
                objLoader.load('Estanteria.obj', (object) => {
                    const texture = textureLoader.load('Texturas/metal.jpg');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(6, 0, -3);
                    object.rotation.y = 80.1;
                    object.scale.set(2.5, 2.5, 2.5);
                    scene.add(object);
                    setVariable(object);
                });
            });
        };

        LoadEstmodel3(scene, (Est) => { Est5 = Est; est5Box = createBoundingBox(Est); });
        LoadEstmodel3(scene, (Est) => { Est6 = Est; est6Box = createBoundingBox(Est); });

        let Est7, Est8;
        const LoadEstmodel4 = (scene, setVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Estanteria/');
            mtlLoader.load('Estanteria.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Estanteria/');
                objLoader.load('Estanteria.obj', (object) => {
                    const texture = textureLoader.load('Texturas/metal.jpg');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(6, 0, 5);
                    object.rotation.y = 80.1;
                    object.scale.set(2.5, 2.5, 2.5);
                    scene.add(object);
                    setVariable(object);
                });
            });
        };

        LoadEstmodel4(scene, (Est) => { Est7 = Est; est7Box = createBoundingBox(Est); });
        LoadEstmodel4(scene, (Est) => { Est8 = Est; est8Box = createBoundingBox(Est); });

        let Est9, Est10;
        const LoadEstmodel5 = (scene, setVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Estanteria/');
            mtlLoader.load('Estanteria.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Estanteria/');
                objLoader.load('Estanteria.obj', (object) => {
                    const texture = textureLoader.load('Texturas/metal.jpg');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(-6.5, 0, -2.5);
                    object.rotation.y = 80.1;
                    object.scale.set(2.5, 2.5, 2.5);
                    scene.add(object);
                    setVariable(object);
                });
            });
        };

        LoadEstmodel5(scene, (Est) => { Est9 = Est; est9Box = createBoundingBox(Est); });
        LoadEstmodel5(scene, (Est) => { Est10 = Est; est10Box = createBoundingBox(Est); });

        let Est11, Est12;
        const LoadEstmodel6 = (scene, setVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Estanteria/');
            mtlLoader.load('Estanteria.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Estanteria/');
                objLoader.load('Estanteria.obj', (object) => {
                    const texture = textureLoader.load('Texturas/metal.jpg');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(-6.5, 0, 4.5);
                    object.rotation.y = 80.1;
                    object.scale.set(2.5, 2.5, 2.5);
                    scene.add(object);
                    setVariable(object);
                });
            });
        };

        LoadEstmodel6(scene, (Est) => { Est11 = Est; est11Box = createBoundingBox(Est); });
        LoadEstmodel6(scene, (Est) => { Est12 = Est; est12Box = createBoundingBox(Est); });

        let Est13, Est14;
        const LoadEstmodel7 = (scene, setVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Estanteria/');
            mtlLoader.load('Estanteria.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Estanteria/');
                objLoader.load('Estanteria.obj', (object) => {
                    const texture = textureLoader.load('Texturas/metal.jpg');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(6.5, 0, -2.5);
                    object.rotation.y = -80.1;
                    object.scale.set(2.5, 2.5, 2.5);
                    scene.add(object);
                    setVariable(object);
                });
            });
        };

        LoadEstmodel7(scene, (Est) => { Est13 = Est; est13Box = createBoundingBox(Est); });
        LoadEstmodel7(scene, (Est) => { Est14 = Est; est14Box = createBoundingBox(Est); });

        let Est15, Est16;
        const LoadEstmodel8 = (scene, setVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Estanteria/');
            mtlLoader.load('Estanteria.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Estanteria/');
                objLoader.load('Estanteria.obj', (object) => {
                    const texture = textureLoader.load('Texturas/metal.jpg');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(6.5, 0, 4.5);
                    object.rotation.y = -80.1;
                    object.scale.set(2.5, 2.5, 2.5);
                    scene.add(object);
                    setVariable(object);
                });
            });
        };

        LoadEstmodel8(scene, (Est) => { Est15 = Est; est15Box = createBoundingBox(Est); });
        LoadEstmodel8(scene, (Est) => { Est16 = Est; est16Box = createBoundingBox(Est); });

        //Contenedor Carne

        let ContC1, ContC2;
        const LoadContCmodel = (scene, setVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Carne/');
            mtlLoader.load('meat_container.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Carne/');
                objLoader.load('meat_container.obj', (object) => {
                    const texture = textureLoader.load('Texturas/metal.jpg');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(7, 0.9, -15);
                    object.rotation.y = 3.14159;
                    object.scale.set(1.2, 1.2, 1.2);
                    scene.add(object);
                    setVariable(object);
                });
            });
        };

        LoadContCmodel(scene, (ContC) => { ContC1 = ContC; contC1Box = createBoundingBox(ContC); });
        LoadContCmodel(scene, (ContC) => { ContC2 = ContC; contC2Box = createBoundingBox(ContC); });

        let ContC3, ContC4;
        const LoadContCmodel2 = (scene, setVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Carne/');
            mtlLoader.load('meat_container.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Carne/');
                objLoader.load('meat_container.obj', (object) => {
                    const texture = textureLoader.load('Texturas/metal.jpg');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(-7, 0.9, -15);
                    object.rotation.y = 3.14159;
                    object.scale.set(1.2, 1.2, 1.2);
                    scene.add(object);
                    setVariable(object);
                });
            });
        };

        LoadContCmodel2(scene, (ContC) => { ContC3 = ContC; contC3Box = createBoundingBox(ContC); });
        LoadContCmodel2(scene, (ContC) => { ContC4 = ContC; contC4Box = createBoundingBox(ContC); });

        const moveSpeed = 0.1;
        const rotateSpeed = 0.02;
        let velocity = new THREE.Vector3();
        const acceleration = 0.01;
        const deceleration = 0.98;

        const keys = {};

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        function detectCollisions() {
            if (cartBox.intersectsBox(contF1Box) || cartBox.intersectsBox(contF2Box) || cartBox.intersectsBox(contF3Box) || cartBox.intersectsBox(contF4Box) ||
                cartBox.intersectsBox(contC1Box) || cartBox.intersectsBox(contC2Box) || cartBox.intersectsBox(contC3Box) || cartBox.intersectsBox(contC4Box) ||
                cartBox.intersectsBox(est1Box) || cartBox.intersectsBox(est2Box) || cartBox.intersectsBox(est3Box) || cartBox.intersectsBox(est4Box) ||
                cartBox.intersectsBox(est5Box) || cartBox.intersectsBox(est6Box) || cartBox.intersectsBox(est7Box) || cartBox.intersectsBox(est8Box) ||
                cartBox.intersectsBox(est9Box) || cartBox.intersectsBox(est10Box) || cartBox.intersectsBox(est11Box) || cartBox.intersectsBox(est12Box) ||
                cartBox.intersectsBox(est13Box) || cartBox.intersectsBox(est14Box) || cartBox.intersectsBox(est15Box) || cartBox.intersectsBox(est16Box)) {
                // Ajustar posición del carrito si hay colisión
                velocity.multiplyScalar(-1);
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (cart) {
                const direction = new THREE.Vector3();
                cart.getWorldDirection(direction);
                if (keys['KeyW']) {
                    velocity.add(direction.multiplyScalar(acceleration));
                }
                if (keys['KeyS']) {
                    velocity.add(direction.multiplyScalar(-acceleration));
                }
                if (keys['KeyA']) {
                    cart.rotation.y += rotateSpeed;
                }
                if (keys['KeyD']) {
                    cart.rotation.y -= rotateSpeed;
                }
                cart.position.add(velocity);
                velocity.multiplyScalar(deceleration);

                updateBoundingBox(cartBox, cart);

                camera.position.set(cart.position.x, cart.position.y + 3, cart.position.z + 5);
                camera.lookAt(cart.position);
            }

            // Movimiento del enemigo
            if (enemy) {
                const direction = new THREE.Vector3();
                direction.subVectors(cart.position, enemy.position).normalize();
                enemy.position.add(direction.multiplyScalar(enemySpeed));

                updateBoundingBox(enemyBox, enemy);

                // Detectar colisión con el carrito
                if (cartBox.intersectsBox(enemyBox)) {
                    alert("¡Te ha atrapado el enemigo! Has perdido.");
                    window.location.reload();
                }
            }

            // Actualiza las bounding boxes de los contenedores y estanterías
            updateBoundingBox(contF1Box, ContF1);
            updateBoundingBox(contF2Box, ContF2);
            updateBoundingBox(contF3Box, ContF3);
            updateBoundingBox(contF4Box, ContF4);
            updateBoundingBox(contC1Box, ContC1);
            updateBoundingBox(contC2Box, ContC2);
            updateBoundingBox(contC3Box, ContC3);
            updateBoundingBox(contC4Box, ContC4);
            updateBoundingBox(est1Box, Est1);
            updateBoundingBox(est2Box, Est2);
            updateBoundingBox(est3Box, Est3);
            updateBoundingBox(est4Box, Est4);
            updateBoundingBox(est5Box, Est5);
            updateBoundingBox(est6Box, Est6);
            updateBoundingBox(est7Box, Est7);
            updateBoundingBox(est8Box, Est8);
            updateBoundingBox(est9Box, Est9);
            updateBoundingBox(est10Box, Est10);
            updateBoundingBox(est11Box, Est11);
            updateBoundingBox(est12Box, Est12);
            updateBoundingBox(est13Box, Est13);
            updateBoundingBox(est14Box, Est14);
            updateBoundingBox(est15Box, Est15);
            updateBoundingBox(est16Box, Est16);

            // Detectar colisiones
            detectCollisions();

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>



       
