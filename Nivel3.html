<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pantry Pursuit: Supermarket</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <script type="module">
        import * as THREE from "./three.module.js";
        import { OrbitControls } from "./OrbitControls.js";
        import { MTLLoader } from "./MTLLoader.js";
        import { OBJLoader } from "./OBJLoader.js";

        const scene = new THREE.Scene();

        // Load background texture
        const textureLoader = new THREE.TextureLoader();
        const backgroundTexture = textureLoader.load('supermarket.jpg', (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            texture.encoding = THREE.sRGBEncoding;
            scene.background = texture;
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === "Escape") {
                window.location.href = "Pausa.html";
            }
        });

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 5);

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const camControl = new OrbitControls(camera, renderer.domElement);
        camControl.listenToKeyEvents(window);
        camControl.keys = { LEFT: 'KeyA', UP: 'KeyW', RIGHT: 'KeyD', BOTTOM: 'KeyS' };
        camControl.enableZoom = false;
        camControl.enableRotate = false;

        const addSupermarketElements = (scene) => {
            const floorGeometry = new THREE.PlaneGeometry(100, 100);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0xCED6C4, transparent: true, opacity: 0.8 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            const ambientLight = new THREE.AmbientLight(0x404040, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1.5);
            directionalLight.position.set(1, 3, 2);
            scene.add(directionalLight);
        };

        addSupermarketElements(scene);

        let cart;
        const cartBoundingBox = new THREE.Box3();

        const loadCartModel = (scene, setCartVariable) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Carrito/');
            mtlLoader.load('carrito.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Carrito/');
                objLoader.load('carrito.obj', (object) => {
                    const texture = textureLoader.load('Texturas/carritoP1.png');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(0, .35, 0);
                    scene.add(object);
                    setCartVariable(object);
                });
            });
        };

        loadCartModel(scene, (cartModel) => { cart = cartModel; });

        const obstacles = [];
        const obstacleBoundingBoxes = [];

        const loadModel = (path, mtlFile, objFile, texturePath, position, scale, rotation, scene) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath(path);
            mtlLoader.load(mtlFile, (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath(path);
                objLoader.load(objFile, (object) => {
                    const texture = textureLoader.load(texturePath);
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(...position);
                    object.scale.set(...scale);
                    if (rotation) object.rotation.set(...rotation);
                    scene.add(object);
                    obstacles.push(object);
                    const boundingBox = new THREE.Box3().setFromObject(object);
                    obstacleBoundingBoxes.push(boundingBox);
                });
            });
        };

        // Load models
        loadModel('Modelos/Manzana/', 'uploads_files_3685626_FS-0011+Apples.mtl', 'uploads_files_3685626_FS-0011+Apples.obj', 'Modelos/Manzana/textures/Apple1_u1_v1_diffuse.jpg', [2.3, 1.7, -15], [5, 5, 5], null, scene);
        loadModel('Modelos/Productos/', 'banana_001.mtl', 'banana_001.obj', 'Modelos/Productos/Textures.png', [3.5, 1.7, -15], [4, 4, 4], [0, 90, 0], scene);
        loadModel('Modelos/Productos/', 'carrot_001.mtl', 'carrot_001.obj', 'Modelos/Productos/Textures.png', [1.3, 1.7, -15], [5, 5, 5], [0, 30, 0], scene);
        loadModel('Modelos/Productos/', 'eggplant_001.mtl', 'eggplant_001.obj', 'Modelos/Productos/Textures.png', [-1.2, 1.7, -15], [4, 4, 4], [0, 10, 0], scene);
        loadModel('Modelos/Productos/', 'peach_001.mtl', 'peach_001.obj', 'Modelos/Productos/Textures.png', [-2.3, 1.7, -15], [4, 4, 4], null, scene);
        loadModel('Modelos/Productos/', 'tomato_001.mtl', 'tomato_001.obj', 'Modelos/Productos/Textures.png', [-3.5, 1.7, -15], [4, 4, 4], null, scene);
        loadModel('Modelos/Productos/', 'chips_001.mtl', 'chips_001.obj', 'Modelos/Productos/Textures.png', [-7, 2.2, 2.5], [4, 4, 4], null, scene);
        loadModel('Modelos/Productos/', 'burger_001.mtl', 'burger_001.obj', 'Modelos/Productos/Textures.png', [18, 2.3, 5], [4, 4, 4], null, scene);
        loadModel('Modelos/Productos/', 'donut_001.mtl', 'donut_001.obj', 'Modelos/Productos/Textures.png', [5.5, 2.4, -4], [4, 4, 4], null, scene);
        loadModel('Modelos/Productos/', 'drink_001.mtl', 'drink_001.obj', 'Modelos/Productos/Textures.png', [-18, 2.3, -3], [3, 3, 3], null, scene);
        loadModel('Modelos/Productos/', 'drink_002.mtl', 'drink_002.obj', 'Modelos/Productos/Textures.png', [-5.5, 2.3, -3], [3, 3, 3], null, scene);
        loadModel('Modelos/Productos/', 'drink_003.mtl', 'drink_003.obj', 'Modelos/Productos/Textures.png', [-7, 2.3, -3], [3, 3, 3], null, scene);
        loadModel('Modelos/Productos/', 'drink_004.mtl', 'drink_004.obj', 'Modelos/Productos/Textures.png', [-18, 2.3, 5], [3, 3, 3], null, scene);
        loadModel('Modelos/Productos/', 'yogurt_001.mtl', 'yogurt_001.obj', 'Modelos/Productos/Textures.png', [-6, 2, -15], [4, 4, 4], null, scene);
        loadModel('Modelos/Productos/', 'sushi_dish_001.mtl', 'sushi_dish_001.obj', 'Modelos/Productos/Textures.png', [-8, 2, -15], [6, 6, 6], [0.261799, 0, 0], scene);
        loadModel('Modelos/Productos/', 'ice_cream_dish_001.mtl', 'ice_cream_dish_001.obj', 'Modelos/Productos/Textures.png', [6, 2, -15], [4, 4, 4], [0.261799, 0, 0], scene);
        loadModel('Modelos/Productos/', 'sausages_001.mtl', 'sausages_001.obj', 'Modelos/Productos/Textures.png', [8, 2, -15], [3, 3, 3], null, scene);
        loadModel('Modelos/Frutas/', 'Frutas_Container.mtl', 'Frutas_Container.obj', 'Texturas/madera.jpg', [2.3, .8, -15], [1, 1, 1], null, scene);
        loadModel('Modelos/Frutas/', 'Frutas_Container.mtl', 'Frutas_Container.obj', 'Texturas/madera.jpg', [-2.3, .8, -15], [1, 1, 1], null, scene);
        loadModel('Modelos/Estanteria/', 'Estanteria.mtl', 'Estanteria.obj', 'Texturas/metal.jpg', [-6, 0, -3], [2.5, 2.5, 2.5], [0, -80.1, 0], scene);
        loadModel('Modelos/Estanteria/', 'Estanteria.mtl', 'Estanteria.obj', 'Texturas/metal.jpg', [-6, 0, 5], [2.5, 2.5, 2.5], [0, -80.1, 0], scene);
        loadModel('Modelos/Estanteria/', 'Estanteria.mtl', 'Estanteria.obj', 'Texturas/metal.jpg', [6, 0, -3], [2.5, 2.5, 2.5], [0, 80.1, 0], scene);
        loadModel('Modelos/Estanteria/', 'Estanteria.mtl', 'Estanteria.obj', 'Texturas/metal.jpg', [6, 0, 5], [2.5, 2.5, 2.5], [0, 80.1, 0], scene);
        loadModel('Modelos/Estanteria/', 'Estanteria.mtl', 'Estanteria.obj', 'Texturas/metal.jpg', [-6.5, 0, -2.5], [2.5, 2.5, 2.5], [0, 80.1, 0], scene);
        loadModel('Modelos/Estanteria/', 'Estanteria.mtl', 'Estanteria.obj', 'Texturas/metal.jpg', [-6.5, 0, 4.5], [2.5, 2.5, 2.5], [0, 80.1, 0], scene);
        loadModel('Modelos/Estanteria/', 'Estanteria.mtl', 'Estanteria.obj', 'Texturas/metal.jpg', [6.5, 0, -2.5], [2.5, 2.5, 2.5], [0, -80.1, 0], scene);
        loadModel('Modelos/Estanteria/', 'Estanteria.mtl', 'Estanteria.obj', 'Texturas/metal.jpg', [6.5, 0, 4.5], [2.5, 2.5, 2.5], [0, -80.1, 0], scene);
        loadModel('Modelos/Estanteria/', 'Estanteria.mtl', 'Estanteria.obj', 'Texturas/metal.jpg', [-18.5, 0, -3], [2.5, 2.5, 2.5], [0, -80.1, 0], scene);
        loadModel('Modelos/Estanteria/', 'Estanteria.mtl', 'Estanteria.obj', 'Texturas/metal.jpg', [-18.5, 0, 5], [2.5, 2.5, 2.5], [0, -80.1, 0], scene);
        loadModel('Modelos/Estanteria/', 'Estanteria.mtl', 'Estanteria.obj', 'Texturas/metal.jpg', [18.5, 0, -3], [2.5, 2.5, 2.5], [0, 80.1, 0], scene);
        loadModel('Modelos/Estanteria/', 'Estanteria.mtl', 'Estanteria.obj', 'Texturas/metal.jpg', [18.5, 0, 5], [2.5, 2.5, 2.5], [0, 80.1, 0], scene);
        loadModel('Modelos/Carne/', 'meat_container.mtl', 'meat_container.obj', 'Texturas/metal.jpg', [7, 0.9, -15], [1.2, 1.2, 1.2], [0, 3.14159, 0], scene);
        loadModel('Modelos/Carne/', 'meat_container.mtl', 'meat_container.obj', 'Texturas/metal.jpg', [-7, 0.9, -15], [1.2, 1.2, 1.2], [0, 3.14159, 0], scene);

        // Create enemy
        const enemyGeometry = new THREE.BoxGeometry(1, 1, 1);
        const enemyMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
        enemy.position.set(0, 0.5, 10);
        scene.add(enemy);

        const enemyBoundingBox = new THREE.Box3().setFromObject(enemy);

        const moveSpeed = 0.1;
        const rotateSpeed = 0.02;
        let velocity = new THREE.Vector3();
        const acceleration = 0.01;
        const deceleration = 0.98;

        const keys = {};

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        const detectCollisions = () => {
            cartBoundingBox.setFromObject(cart);
            enemyBoundingBox.setFromObject(enemy);

            for (let i = 0; i < obstacleBoundingBoxes.length; i++) {
                if (cartBoundingBox.intersectsBox(obstacleBoundingBoxes[i])) {
                    return true;
                }
            }

            if (cartBoundingBox.intersectsBox(enemyBoundingBox)) {
                alert("You Lose! The enemy caught you!");
                window.location.reload();
            }

            return false;
        };

        function animate() {
            requestAnimationFrame(animate);

            if (cart) {
                const direction = new THREE.Vector3();
                cart.getWorldDirection(direction);
                if (keys['KeyW']) {
                    velocity.add(direction.multiplyScalar(acceleration));
                }
                if (keys['KeyS']) {
                    velocity.add(direction.multiplyScalar(-acceleration));
                }
                if (keys['KeyA']) {
                    cart.rotation.y += rotateSpeed;
                }
                if (keys['KeyD']) {
                    cart.rotation.y -= rotateSpeed;
                }
                cart.position.add(velocity);
                velocity.multiplyScalar(deceleration);

                if (detectCollisions()) {
                    cart.position.sub(velocity); // Revert the position change if collision detected
                    velocity.set(0, 0, 0); // Stop the cart's movement
                }

                // Enemy follows the cart
                const enemyDirection = new THREE.Vector3().subVectors(cart.position, enemy.position).normalize();
                enemy.position.add(enemyDirection.multiplyScalar(0.05));

                camera.position.set(cart.position.x, cart.position.y + 3, cart.position.z + 5);
                camera.lookAt(cart.position);
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
