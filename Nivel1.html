<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pantry Pursuit: Supermarket</title>
    <style>
        .divider {
            position: absolute;
            top: 0;
            left: 50%;
            width: 2px;
            height: 100%;
            background-color: #000;
            z-index: 1000;
        }
        #scoreboard {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            z-index: 1001;
            color: #fff;
        }
        #timer {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            z-index: 1001;
            color: #fff;
        }
    </style>
</head>
<body>
    <div id="scoreboard">
        <span id="player1Name"></span> Score: <span id="score1">0</span> | <span id="player2Name"></span> Score: <span id="score2">0</span>
    </div>
    <div id="timer">Time Left: <span id="time">60</span> seconds</div>
    <script type="module">
        import * as THREE from "./three.module.js";
        import { OrbitControls } from "./OrbitControls.js";
        import { MTLLoader } from "./MTLLoader.js";
        import { OBJLoader } from "./OBJLoader.js";

        const player1Name = localStorage.getItem('player1Name');
        const player2Name = localStorage.getItem('player2Name');
        document.getElementById('player1Name').textContent = player1Name;
        document.getElementById('player2Name').textContent = player2Name;

        const scene1 = new THREE.Scene();
        const scene2 = new THREE.Scene();

        const textureLoader = new THREE.TextureLoader();
        const backgroundTexture = textureLoader.load('supermarket.jpg', (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            texture.encoding = THREE.sRGBEncoding;
            scene1.background = texture;
            scene2.background = texture;
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === "Escape") {
                window.location.href = "Pausa.html";
            }
        });

        const createCameraAndRenderer = (positionX, positionY, positionZ, elementStyleLeft) => {
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / 2 / window.innerHeight, 0.1, 1000);
            camera.position.set(positionX, positionY, positionZ);

            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth / 2, window.innerHeight);
            renderer.domElement.style.position = "absolute";
            renderer.domElement.style.top = "0";
            renderer.domElement.style.left = elementStyleLeft;
            document.body.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.listenToKeyEvents(window);
            controls.enableZoom = false;
            controls.enableRotate = false;

            return { camera, renderer, controls };
        };

        const { camera: camera1, renderer: renderer1, controls: controls1 } = createCameraAndRenderer(0, 3, 5, "0");
        const { camera: camera2, renderer: renderer2, controls: controls2 } = createCameraAndRenderer(0, 3, 5, `${window.innerWidth / 2}px`);

        controls1.keys = { LEFT: 'KeyA', UP: 'KeyW', RIGHT: 'KeyD', BOTTOM: 'KeyS' };
        controls2.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };

        const addSupermarketElements = (scene) => {
            const floorGeometry = new THREE.PlaneGeometry(100, 100);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0xCED6C4, transparent: true, opacity: 0.8 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            const ambientLight = new THREE.AmbientLight(0x404040, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1.5);
            directionalLight.position.set(1, 3, 2);
            scene.add(directionalLight);
        };

        addSupermarketElements(scene1);
        addSupermarketElements(scene2);

        const itemBoundingBoxes1 = [];
        const itemBoundingBoxes2 = [];
        const itemPoints1 = [];
        const itemPoints2 = [];
        const containerBoundingBoxes1 = [];
        const containerBoundingBoxes2 = [];
        const obstacleBoundingBoxes1 = [];
        const obstacleBoundingBoxes2 = [];
        const obstaclePoints = [];
        const obstacleGroups1 = [];
        const obstacleGroups2 = [];

        const addBoundingBox = (object, boundingBoxArray, pointsArray, points) => {
            const box = new THREE.Box3().setFromObject(object);
            boundingBoxArray.push(box);
            if (pointsArray && points !== undefined) {
                pointsArray.push(points);
            }
        };

        const loadModel = (path, file, texturePath, position, scale, rotation, group, boundingBoxArray, pointsArray, points) => {
            return new Promise((resolve, reject) => {
                const mtlLoader = new MTLLoader();
                mtlLoader.setPath(path);
                mtlLoader.load(file + '.mtl', (materials) => {
                    materials.preload();
                    const objLoader = new OBJLoader();
                    objLoader.setMaterials(materials);
                    objLoader.setPath(path);
                    objLoader.load(file + '.obj', (object) => {
                        const texture = textureLoader.load(texturePath);
                        texture.encoding = THREE.sRGBEncoding;
                        object.traverse((child) => {
                            if (child.isMesh) {
                                child.material.map = texture;
                                child.material.color.set(0xFFFFFF);
                            }
                        });
                        object.position.set(position.x, position.y, position.z);
                        object.scale.set(scale.x, scale.y, scale.z);
                        if (rotation) {
                            object.rotation.set(rotation.x, rotation.y, rotation.z);
                        }
                        group.add(object);
                        addBoundingBox(object, boundingBoxArray, pointsArray, points);
                        resolve(object);
                    });
                });
            });
        };

        const itemPositions = [
            { path: 'Modelos/Manzana/', file: 'uploads_files_3685626_FS-0011+Apples', texturePath: 'Modelos/Manzana/textures/Apple1_u1_v1_diffuse.jpg', position: { x: 2.3, y: 1.7, z: -8 }, scale: { x: 5, y: 5, z: 5 }, points: 10, container: 'container1' },
            { path: 'Modelos/Productos/', file: 'banana_001', texturePath: 'Modelos/Productos/Textures.png', position: { x: 3.5, y: 1.7, z: -8 }, scale: { x: 4, y: 4, z: 4 }, rotation: { x: 0, y: Math.PI / 2, z: 0 }, points: 20, container: 'container1' },
            { path: 'Modelos/Productos/', file: 'carrot_001', texturePath: 'Modelos/Productos/Textures.png', position: { x: 1.3, y: 1.7, z: -8 }, scale: { x: 5, y: 5, z: 5 }, rotation: { x: 0, y: Math.PI / 6, z: 0 }, points: 15, container: 'container1' },
            { path: 'Modelos/Productos/', file: 'eggplant_001', texturePath: 'Modelos/Productos/Textures.png', position: { x: -1.2, y: 1.7, z: -8 }, scale: { x: 4, y: 4, z: 4 }, rotation: { x: 0, y: Math.PI / 18, z: 0 }, points: 25, container: 'container2' },
            { path: 'Modelos/Productos/', file: 'peach_001', texturePath: 'Modelos/Productos/Textures.png', position: { x: -2.3, y: 1.7, z: -8 }, scale: { x: 4, y: 4, z: 4 }, points: 30, container: 'container2' },
            { path: 'Modelos/Productos/', file: 'tomato_001', texturePath: 'Modelos/Productos/Textures.png', position: { x: -3.5, y: 1.7, z: -8 }, scale: { x: 4, y: 4, z: 4 }, points: 5, container: 'container2' },
            { path: 'Modelos/Productos/', file: 'chips_001', texturePath: 'Modelos/Productos/Textures.png', position: { x: -5.5, y: 2.2, z: -4 }, scale: { x: 4, y: 4, z: 4 }, points: 50, container: 'container3' },
            { path: 'Modelos/Productos/', file: 'burger_001', texturePath: 'Modelos/Productos/Textures.png', position: { x: 5.5, y: 2.4, z: -1 }, scale: { x: 4, y: 4, z: 4 }, points: 60, container: 'container3' },
            { path: 'Modelos/Productos/', file: 'donut_001', texturePath: 'Modelos/Productos/Textures.png', position: { x: -6.5, y: 2.4, z: 4 }, scale: { x: 4, y: 4, z: 4 }, points: 35, container: 'container4' },
            { path: 'Modelos/Productos/', file: 'drink_001', texturePath: 'Modelos/Productos/Textures.png', position: { x: 6.5, y: 2.3, z: 5 }, scale: { x: 3, y: 3, z: 3 }, points: 40, container: 'container4' },
        ];

        const obstaclePositions = [
            { path: 'Modelos/Frutas/', file: 'Frutas_Container', texturePath: 'Modelos/Jugo/depositphotos_666327950-stock-illustration-strawberry-clipart-seamless-pattern-bundle.jpg', position: { x: 2.3, y: 0.8, z: -8 }, scale: { x: 1, y: 1, z: 1 }, points: 10, associatedItems: ['uploads_files_3685626_FS-0011+Apples', 'banana_001', 'carrot_001'] },
            { path: 'Modelos/Frutas/', file: 'Frutas_Container', texturePath: 'Modelos/Jugo/depositphotos_666327950-stock-illustration-strawberry-clipart-seamless-pattern-bundle.jpg', position: { x: -2.3, y: 0.8, z: -8 }, scale: { x: 1, y: 1, z: 1 }, points: 25, associatedItems: ['eggplant_001', 'peach_001', 'tomato_001'] },
            { path: 'Modelos/Estanteria/', file: 'Estanteria', texturePath: 'Modelos/Lata/TinCan4Metal.png', position: { x: -6, y: 0, z: -3 }, scale: { x: 2.5, y: 2.5, z: 2.5 }, rotation: { x: 0, y: 80.1 * Math.PI / 180, z: 0 }, points: 50, associatedItems: ['chips_001', 'burger_001'] },
            { path: 'Modelos/Estanteria/', file: 'Estanteria', texturePath: 'Modelos/Lata/TinCan4Metal.png', position: { x: -7, y: 0, z: 3 }, scale: { x: 2.5, y: 2.5, z: 2.5 }, rotation: { x: 0, y: 80.1 * Math.PI / 180, z: 0 }, points: 35, associatedItems: ['donut_001', 'drink_001'] },
            { path: 'Modelos/Estanteria/', file: 'Estanteria', texturePath: 'Modelos/Lata/TinCan4Metal.png', position: { x: 6, y: 0, z: -3 }, scale: { x: 2.5, y: 2.5, z: 2.5 }, rotation: { x: 0, y: -80.1 * Math.PI / 180, z: 0 }, points: 50, associatedItems: ['chips_001', 'burger_001'] },
            { path: 'Modelos/Estanteria/', file: 'Estanteria', texturePath: 'Modelos/Lata/TinCan4Metal.png', position: { x: 7, y: 0, z: 3 }, scale: { x: 2.5, y: 2.5, z: 2.5 }, rotation: { x: 0, y: -80.1 * Math.PI / 180, z: 0 }, points: 35, associatedItems: ['donut_001', 'drink_001'] },
            { path: 'Modelos/Carne/', file: 'meat_container', texturePath: 'Modelos/Lata/TinCan4Metal.png', position: { x: 0, y: 0.9, z: 12 }, scale: { x: 1.2, y: 1.2, z: 1.2 }, points: 0, associatedItems: [] },
        ];

        const loadItemsAndObstacles = async () => {
            const containerGroups1 = {};
            const containerGroups2 = {};

            // Create groups for each container
            for (const item of itemPositions) {
                if (!containerGroups1[item.container]) {
                    containerGroups1[item.container] = new THREE.Group();
                    containerGroups2[item.container] = new THREE.Group();
                    scene1.add(containerGroups1[item.container]);
                    scene2.add(containerGroups2[item.container]);

                    // Create a bounding box for the container
                    const containerBoundingBox1 = new THREE.Box3();
                    containerBoundingBox1.setFromObject(containerGroups1[item.container]);
                    containerBoundingBoxes1.push(containerBoundingBox1);

                    const containerBoundingBox2 = new THREE.Box3();
                    containerBoundingBox2.setFromObject(containerGroups2[item.container]);
                    containerBoundingBoxes2.push(containerBoundingBox2);
                }
            }

            await Promise.all([
                ...itemPositions.map(item => loadModel(item.path, item.file, item.texturePath, item.position, item.scale, item.rotation, containerGroups1[item.container], itemBoundingBoxes1, itemPoints1, item.points)),
                ...itemPositions.map(item => loadModel(item.path, item.file, item.texturePath, item.position, item.scale, item.rotation, containerGroups2[item.container], itemBoundingBoxes2, itemPoints2, item.points)),
                ...obstaclePositions.map(obstacle => loadModel(obstacle.path, obstacle.file, obstacle.texturePath, obstacle.position, obstacle.scale, obstacle.rotation, scene1, obstacleBoundingBoxes1, obstaclePoints, obstacle.points).then(object => obstacleGroups1.push(object))),
                ...obstaclePositions.map(obstacle => loadModel(obstacle.path, obstacle.file, obstacle.texturePath, obstacle.position, obstacle.scale, obstacle.rotation, scene2, obstacleBoundingBoxes2, obstaclePoints, obstacle.points).then(object => obstacleGroups2.push(object))),
            ]);
        };

        loadItemsAndObstacles();

        let cart1, cart2;
        const cartBoundingBox1 = new THREE.Box3();
        const cartBoundingBox2 = new THREE.Box3();

        const loadCartModel = (scene, setCartVariable, cartBoundingBox) => {
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath('Modelos/Carrito/');
            mtlLoader.load('carrito.mtl', (materials) => {
                materials.preload();
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Modelos/Carrito/');
                objLoader.load('carrito.obj', (object) => {
                    const texture = textureLoader.load('Texturas/carritoP1.png');
                    texture.encoding = THREE.sRGBEncoding;
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material.map = texture;
                            child.material.color.set(0xFFFFFF);
                        }
                    });
                    object.position.set(0, .35, 0);
                    scene.add(object);
                    setCartVariable(object);
                    cartBoundingBox.setFromObject(object);
                });
            });
        };

        loadCartModel(scene1, (cart) => { cart1 = cart; }, cartBoundingBox1);
        loadCartModel(scene2, (cart) => { cart2 = cart; }, cartBoundingBox2);

        const shelfFruits = {
            'container1': ['uploads_files_3685626_FS-0011+Apples', 'banana_001', 'carrot_001'],
            'container2': ['eggplant_001', 'peach_001', 'tomato_001'],
            'container3': ['chips_001', 'burger_001'],
            'container4': ['donut_001', 'drink_001'],
        };

        let goldenObstacle = null;
        let goldenObstacleTimeout = null;

        const makeObstacleGolden = () => {
            const randomIndex = Math.floor(Math.random() * obstacleGroups1.length);
            goldenObstacle = randomIndex;
            const obstacleGroup1 = obstacleGroups1[goldenObstacle];
            const obstacleGroup2 = obstacleGroups2[goldenObstacle];

            obstacleGroup1.traverse((child) => {
                if (child.isMesh) {
                    child.material.color.set(0xFFD700); // Gold color
                }
            });

            obstacleGroup2.traverse((child) => {
                if (child.isMesh) {
                    child.material.color.set(0xFFD700); // Gold color
                }
            });

            goldenObstacleTimeout = setTimeout(() => {
                obstacleGroup1.traverse((child) => {
                    if (child.isMesh) {
                        child.material.color.set(0xFFFFFF); // Reset to white color
                    }
                });

                obstacleGroup2.traverse((child) => {
                    if (child.isMesh) {
                        child.material.color.set(0xFFFFFF); // Reset to white color
                    }
                });

                goldenObstacle = null;
            }, 10000); // 10 seconds
        };

        // Crear la caja rosa
        let pinkBox1, pinkBox2;
        const pinkBoxBoundingBox1 = new THREE.Box3();
        const pinkBoxBoundingBox2 = new THREE.Box3();
        let pinkBoxCollected = false;

        const createPinkBox = (scene, setPinkBoxVariable, pinkBoxBoundingBox) => {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshLambertMaterial({ color: 0xFFC0CB });
            const box = new THREE.Mesh(geometry, material);
            box.position.set(0, 0.5, 7);
            scene.add(box);
            setPinkBoxVariable(box);
            pinkBoxBoundingBox.setFromObject(box);
        };

        createPinkBox(scene1, (box) => { pinkBox1 = box; }, pinkBoxBoundingBox1);
        createPinkBox(scene2, (box) => { pinkBox2 = box; }, pinkBoxBoundingBox2);

        // Crear el ticket verde
        let ticket1, ticket2;
        const ticketBoundingBox1 = new THREE.Box3();
        const ticketBoundingBox2 = new THREE.Box3();
        let ticketCollected = false;
        let ticketVisible = false;

        const createTicket = (scene, setTicketVariable, ticketBoundingBox) => {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshLambertMaterial({ color: 0x00FF00 }); // Verde
            const box = new THREE.Mesh(geometry, material);
            box.position.set(3, 0.5, -4);
            scene.add(box);
            setTicketVariable(box);
            ticketBoundingBox.setFromObject(box);
            box.visible = false; // Ocultar inicialmente
        };

        createTicket(scene1, (ticket) => { ticket1 = ticket; }, ticketBoundingBox1);
        createTicket(scene2, (ticket) => { ticket2 = ticket; }, ticketBoundingBox2);

        // Mostrar el ticket después de 15 segundos
        setTimeout(() => {
            ticket1.visible = true;
            ticket2.visible = true;
            ticketVisible = true;
        }, 15000);

        // Crear el ticket morado
        let purpleTicket1, purpleTicket2;
        const purpleTicketBoundingBox1 = new THREE.Box3();
        const purpleTicketBoundingBox2 = new THREE.Box3();
        let purpleTicketCollected = false;
        let purpleTicketVisible = false;

        const createPurpleTicket = (scene, setPurpleTicketVariable, purpleTicketBoundingBox) => {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshLambertMaterial({ color: 0x800080 }); // Morado
            const box = new THREE.Mesh(geometry, material);
            box.position.set(3, 0.5, -2);
            scene.add(box);
            setPurpleTicketVariable(box);
            purpleTicketBoundingBox.setFromObject(box);
            box.visible = false; // Ocultar inicialmente
        };

        createPurpleTicket(scene1, (purpleTicket) => { purpleTicket1 = purpleTicket; }, purpleTicketBoundingBox1);
        createPurpleTicket(scene2, (purpleTicket) => { purpleTicket2 = purpleTicket; }, purpleTicketBoundingBox2);

        // Mostrar el ticket morado después de 25 segundos
        setTimeout(() => {
            purpleTicket1.visible = true;
            purpleTicket2.visible = true;
            purpleTicketVisible = true;
        }, 25000);

        let player1Frozen = false;
        let player2Frozen = false;

        const freezePlayer = (player) => {
            if (player === 1) {
                player1Frozen = true;
                setTimeout(() => {
                    player1Frozen = false;
                }, 6000);
            } else if (player === 2) {
                player2Frozen = true;
                setTimeout(() => {
                    player2Frozen = false;
                }, 6000);
            }
        };

        const checkCollisions = (cart, cartBoundingBox, itemBoundingBoxes, itemPoints, obstacleBoundingBoxes, containerBoundingBoxes, shelfFruits, pinkBox, pinkBoxBoundingBox, ticket, ticketBoundingBox, purpleTicket, purpleTicketBoundingBox, player) => {
            cartBoundingBox.setFromObject(cart);

            // Check collision with items
            for (let i = 0; i < itemBoundingBoxes.length; i++) {
                const box = itemBoundingBoxes[i];
                if (cartBoundingBox.intersectsBox(box)) {
                    const points = itemPoints[i];
                    itemBoundingBoxes.splice(i, 1);
                    itemPoints.splice(i, 1);
                    return { type: 'item', points: points };
                }
            }

            // Check collision with obstacles
            for (let i = 0; i < obstacleBoundingBoxes.length; i++) {
                const box = obstacleBoundingBoxes[i];
                if (cartBoundingBox.intersectsBox(box)) {
                    let points = obstaclePoints[i];
                    if (goldenObstacle === i) {
                        points *= 2; // Double points if the obstacle is golden
                    }
                    return { type: 'obstacle', points: points };
                }
            }

            // Check collision with shelves
            for (let i = 0; i < containerBoundingBoxes.length; i++) {
                const box = containerBoundingBoxes[i];
                if (cartBoundingBox.intersectsBox(box)) {
                    const containerName = Object.keys(containerGroups1)[i]; // Assuming containerGroups1 and containerGroups2 have the same keys
                    const fruits = shelfFruits[containerName] || [];
                    let points = 0;
                    for (let j = 0; j < itemPositions.length; j++) {
                        if (fruits.includes(itemPositions[j].file)) {
                            points += itemPositions[j].points;
                            // Remove collected items from the scene and bounding boxes
                            itemBoundingBoxes.splice(j, 1);
                            itemPoints.splice(j, 1);
                            j--; // Adjust index after removal
                        }
                    }
                    return { type: 'shelf', points: points };
                }
            }

            // Check collision with the pink box
            if (cartBoundingBox.intersectsBox(pinkBoxBoundingBox) && !pinkBoxCollected) {
                pinkBoxCollected = true;
                scene1.remove(pinkBox1);
                scene2.remove(pinkBox2);
                return { type: 'pinkBox', points: 150 };
            }

            // Check collision with the green ticket
            if (ticketVisible && cartBoundingBox.intersectsBox(ticketBoundingBox) && !ticketCollected) {
                ticketCollected = true;
                scene1.remove(ticket1);
                scene2.remove(ticket2);
                if (player === 1) {
                    return { type: 'ticket', points: -50, opponent: 2 };
                } else {
                    return { type: 'ticket', points: -50, opponent: 1 };
                }
            }

            // Check collision with the purple ticket
            if (purpleTicketVisible && cartBoundingBox.intersectsBox(purpleTicketBoundingBox) && !purpleTicketCollected) {
                purpleTicketCollected = true;
                scene1.remove(purpleTicket1);
                scene2.remove(purpleTicket2);
                if (player === 1) {
                    freezePlayer(2);
                    return { type: 'purpleTicket', points: 0 };
                } else {
                    freezePlayer(1);
                    return { type: 'purpleTicket', points: 0 };
                }
            }

            return null;
        };

        const moveSpeed = 0.1;
        const rotateSpeed = 0.02;
        let velocity1 = new THREE.Vector3();
        let velocity2 = new THREE.Vector3();
        const acceleration = 0.01;
        const deceleration = 0.98;

        const keys1 = {};
        const keys2 = {};

        document.addEventListener('keydown', (e) => {
            keys1[e.code] = true;
            keys2[e.code] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys1[e.code] = false;
            keys2[e.code] = false;
        });

        let score1 = 0;
        let score2 = 0;
        let timeLeft = 60;

        const updateScore = (player, score) => {
            document.getElementById(`score${player}`).textContent = score;
        };

        const updateTime = () => {
            document.getElementById('time').textContent = timeLeft;
        };

        const saveScore = (name, score) => {
            const scores = JSON.parse(localStorage.getItem('scores')) || [];
            scores.push({ name, score });
            localStorage.setItem('scores', JSON.stringify(scores));
        };

        const timer = setInterval(() => {
            timeLeft--;
            if (timeLeft <= 0) {
                clearInterval(timer);
                clearInterval(goldenTimer);
                saveScore(player1Name, score1);
                saveScore(player2Name, score2);
                alert(`Game Over! Final Scores: ${player1Name}: ${score1}, ${player2Name}: ${score2}`);
                window.location.reload();
            }
            updateTime();
        }, 1000);

        const goldenTimer = setInterval(makeObstacleGolden, 20000); // Make an obstacle golden every 20 seconds

        function animate() {
            requestAnimationFrame(animate);

            if (cart1 && !player1Frozen) {
                const direction1 = new THREE.Vector3();
                cart1.getWorldDirection(direction1);
                if (keys1['KeyW']) {
                    velocity1.add(direction1.multiplyScalar(acceleration));
                }
                if (keys1['KeyS']) {
                    velocity1.add(direction1.multiplyScalar(-acceleration));
                }
                if (keys1['KeyA']) {
                    cart1.rotation.y += rotateSpeed;
                }
                if (keys1['KeyD']) {
                    cart1.rotation.y -= rotateSpeed;
                }
                cart1.position.add(velocity1);

                const collision1 = checkCollisions(cart1, cartBoundingBox1, itemBoundingBoxes1, itemPoints1, obstacleBoundingBoxes1, containerBoundingBoxes1, shelfFruits, pinkBox1, pinkBoxBoundingBox1, ticket1, ticketBoundingBox1, purpleTicket1, purpleTicketBoundingBox1, 1);
                if (collision1 && collision1.type === 'item') {
                    score1 += collision1.points;
                    updateScore(1, score1);
                } else if (collision1 && collision1.type === 'obstacle') {
                    score1 += collision1.points; // Add points for obstacle collision
                    updateScore(1, score1);
                    cart1.position.add(velocity1.multiplyScalar(-.98));
                    velocity1.set(0, 0, 0);
                } else if (collision1 && collision1.type === 'shelf') {
                    score1 += collision1.points;
                    updateScore(1, score1);
                } else if (collision1 && collision1.type === 'pinkBox') {
                    score1 += collision1.points;
                    updateScore(1, score1);
                } else if (collision1 && collision1.type === 'ticket') {
                    if (collision1.opponent === 2) {
                        score2 += collision1.points;
                        updateScore(2, score2);
                    }
                } else if (collision1 && collision1.type === 'purpleTicket') {
                    // Effect already handled in checkCollisions
                }
                velocity1.multiplyScalar(deceleration);

                camera1.position.set(cart1.position.x, cart1.position.y + 3, cart1.position.z + 5);
                camera1.lookAt(cart1.position);
            }

            if (cart2 && !player2Frozen) {
                const direction2 = new THREE.Vector3();
                cart2.getWorldDirection(direction2);
                if (keys2['ArrowUp']) {
                    velocity2.add(direction2.multiplyScalar(acceleration));
                }
                if (keys2['ArrowDown']) {
                    velocity2.add(direction2.multiplyScalar(-acceleration));
                }
                if (keys2['ArrowLeft']) {
                    cart2.rotation.y += rotateSpeed;
                }
                if (keys2['ArrowRight']) {
                    cart2.rotation.y -= rotateSpeed;
                }
                cart2.position.add(velocity2);

                const collision2 = checkCollisions(cart2, cartBoundingBox2, itemBoundingBoxes2, itemPoints2, obstacleBoundingBoxes2, containerBoundingBoxes2, shelfFruits, pinkBox2, pinkBoxBoundingBox2, ticket2, ticketBoundingBox2, purpleTicket2, purpleTicketBoundingBox2, 2);
                if (collision2 && collision2.type === 'item') {
                    score2 += collision2.points;
                    updateScore(2, score2);
                } else if (collision2 && collision2.type === 'obstacle') {
                    score2 += collision2.points; // Add points for obstacle collision
                    updateScore(2, score2);
                    cart2.position.add(velocity2.multiplyScalar(-.98));
                    velocity2.set(0, 0, 0);
                } else if (collision2 && collision2.type === 'shelf') {
                    score2 += collision2.points;
                    updateScore(2, score2);
                } else if (collision2 && collision2.type === 'pinkBox') {
                    score2 += collision2.points;
                    updateScore(2, score2);
                } else if (collision2 && collision2.type === 'ticket') {
                    if (collision2.opponent === 1) {
                        score1 += collision2.points;
                        updateScore(1, score1);
                    }
                } else if (collision2 && collision2.type === 'purpleTicket') {
                    // Effect already handled in checkCollisions
                }
                velocity2.multiplyScalar(deceleration);

                camera2.position.set(cart2.position.x, cart2.position.y + 3, cart2.position.z + 5);
                camera2.lookAt(cart2.position);
            }

            renderer1.render(scene1, camera1);
            renderer2.render(scene2, camera2);
        }

        animate();
    </script>

    <div class="divider"></div>
</body>
</html>
